---
title: "ronronando"
author: "Pedro de Brito"
date: "06/07/2021"
output: html_document
---

Neste post vamos falar de mais um pacote da família tidyverse: o `purrr`. `purrr` é um pacote que possui diversas ferramentas para trabalhar com funções e vetores. Muitas funções do pacote tem como objetivo aprimorar o uso da programação funcional (FP), já que o R não é uma linguagem diretamente ligada a FP. FP é, em resumo, quando seu código é organizado em funções que realizam as operações de que você precisa, ou seja, em muitos casos você cria suas próprias funções. Aqui vamos tentar mostrar como usar o `purrr` focando na sua principal função: `map()`.  

Como já dito, o pacote pertence ao `tidyverse` então você pode carregá-lo pelo usando o comando `library(tidyverse)` ou separadamente `library(purrr)`. Para os exemplos do post iremos trabalhar com um banco de dados `iris` que o próprio R possui. Você pode carregar bases de dados que o R possui utilizando o comando `data()`


```{r, message = F, warning=FALSE}
library(purrr)
library(dplyr)
```


# _"map()"_

Dentre as diversas funções do pacote `purrr` uma das mais conhecidas e utilizadas é a `map()` e suas variações, nada mais justo do que começar falando dela. Essa função (e suas variações) é usada para aplicar a mesma ação/função a todos elementos de um objeto. Esses objetos podem ser uma lista, um vetor, variáveis de um banco de dados, etc. Esse tipo de função é muito útil para evitar usar *loops* e `for`'s.
  
Se em algum momento você já fez uso da família de funções `apply()` você pode ter percebido uma certa semelhança entre elas. Existem algumas discussões entre o uso das funções `apply()` e `map()`. Não é o foco deste post fazer uma comparação aprofundada sobre essas funções, mas podemos trazer alguns pontos. De forma geral, escolher qual delas usar vai depender de um  contexto. Em questão de tempo bruto de execução, a família `apply()` é ligeiramente mais rápida (a diferença é bem pequena), porém as funções de `map()` são mais convenientes. Todas as suas variações seguem a mesma ordem de argumentos (o primeiro argumento é sempre o vetor), diferente da família `apply()`, onde os argumentos podem mudar. Existem mais pontos a serem considerados, mas em resumo, se ignorar questões de sintaxe e funcionalidade (as variações de `map()`), decidir qual delas usar restringe-se a usar as funções base do R ou utilizar funções obtidas por meio de pacotes, neste caso o `purrr`.

Voltando ao foco, vamos mostrar algumas variações (não todas) de `map()`.
  
- `map(.x, .f)` é a principal função de mapeamento e retorna uma lista.

- `map_df(.x, .f)` retorna um `data.frame`.

- `map_dbl(.x, .f)` retorna um vetor numérico (duplo).

- `map_chr(.x, .f)` retorna um vetor de caracteres.

- `map_lgl(.x, .f)` retorna um vetor lógico.
  
Essas funções, assim como a maiores das funções do universo `tidyverse`, tem como primeiro argumento o objeto a qual você deseja aplicar uma certa função e o segundo argumento é a função a ser aplicada em cada elemento do seu objeto. Para ficar mais claro vamos a uma breve aplicação e ao decorrer do post, iremos utilizar mais as outras funções. 
Vamos criar um vetor com poucos elementos para usar como exemplo, depois criar uma função qualquer e usar o `map()` para aplicar essa função em cada elemento do vetor.


```{r}
vetor_ex <- c(0, 3, 6, 9, 12)

funcao1 <- function(x){
  return(x^2)
}

map(vetor_ex, funcao1)

map_chr(vetor_ex, funcao1)
```

Note que usar apenas `map()`, como dito antes, irá retornar uma lista onde o primeiro elemento da saída é o resultado da aplicação da função ao primeiro elemento da entrada e assim por diante. 
já quando usamos `map_chr()` a função nos retorna um vetor de caracteres.

Vamos agora criar uma lista com alguns vetores. Caso a gente queira, por exemplo, tirar a média de cada um dos vetores dentro da lista, precisaríamos fazer isso acessando cada elemento da lista, criando funções complexas ou utilizando for's e loop's. Veja abaixo como o `map()` pode nos ajudar. 

```{r}
lista_ex <- list(c(1, 2, 3),
                 seq(0,100,10),
                 c(1:10))

lista_ex

lista_ex %>% 
  map(mean)

lista_ex %>% 
  map_dbl(sd)
```

Note também que fizemos o uso da função junto com o *pipe* e é bem comum essa prática. Lembrando que já explicamos como utilizar o *pipe*,  caso tenha alguma dúvida você pode acessar o post que contém essa explicação cliquando [aqui](https://daslab-ufes.github.io/tidyverse/).

Nos exemplos acima utilizamos uma função criada por nós e outras já presentes dentro do R. Além dessas, também é possível fazer o que chamamos de funções anônimas. Uma função anônima é basicamente uma função criada e usada, mas nunca atribuída a um objeto. Esse tipo de função é bem útilizada dentro do `map()`. Para usar essa função você começa com um `~` (para indicar que você começou uma função anônima). O argumento da função é consultado utilizando o `.x` ou apenas `.`, diferente das funções normais onde você consegue usar qualquer argumento. Para ficar mais claro vamos a um exemplo.

```{r}
map_dbl(vetor_ex, ~ .x ^2)

vetor_ex %>% 
  map_dbl(~ .x ^2)

vetor_ex %>% 
  map_dbl(~ . ^2)

vetor_ex %>% 
  map_dbl(~{.x ^2})
```

Acima mostramos maneiras diferentes de utilizar funções anônimas. Todas retornam o mesmo resultado (e deveriam). Um destaque para a última onde foi usado `{}`. O uso das chaves é interessante para organização e boas práticas no seu código, principalmente se a sua função for mais complexa.  


Uma função muito útil também é a `modify()`. Ela funciona de forma igual à função `map()`, a diferença é que ela sempre irá retornar um objeto do mesmo tipo que o objeto de entrada. Por exemplo, se meu objeto de entradar um vetor de caracteres, a saída também será um vetor de caracteres. Também já fizemos um [post](https://daslab-ufes.github.io/boas-praticas/) sobre boas práticas no software R.


```{r}
objeto <- data.frame(x = c(1, 10, 11),
                     y = c(9, 20, 30))

modify(objeto, funcao1)
```

A função `modify()` possui uma variação interessante. A `modify_if()` permite que você forneça um critério e assim, a função só será aplicada aos elementos que atendam a esse critério. O critério torna-se o segundo argumento da função, ou seja, o primeiro argumento continua sendo o objeto de entrada, o segundo passa a ser o critério e o terceiro argumento é a função. Para ficar mais claro vamos a um exemplo


```{r}
modify_if(vetor_ex,
          ~ . >= 9,
          funcao1)
```

Veja que a função só foi aplicada para valores maiores ou iguais a 9.

Agora que temos uma noção de como funciona as funções `map()`, vamos deixar as coisas um pouco mais interessantes trabalhando com uma base de dados. Para os exemplos do post iremos trabalhar com um banco de dados "iris" que o próprio R possui. Você pode olhar bases de dados que o R possui utilizando o comando `data()`


```{r}
dados <- iris
# visualizando os 10 primeiros dados da tabela
knitr::kable(head(dados, 10))
```

Como estamos trabalhando com uma base de dados, as funções serão aplicadas em cada coluna. Por exemplo, ao aplicar uma função para resumir de alguma maneira os dados, ela irá fazer isso para cada uma das colunas. Vamos começar utilizando a função `n_distinct()` do pacote `dplyr()` que nos retorna o número de valores distintos em cada coluna.

```{r}
dados %>% 
  map(n_distinct)
```

Observe que `map()` aplicou a função desejada em cada uma das 5 variáveis do nosso banco de dados e retornou o valor correspondente. 


Vamos começar a fazer algo mais elaborado. Podemos querer retornar algumas medidas resumos ou outras informações gerais sobre nossos dados em um quadro de dados. Essa uma maneira bem legal e útil de utilizar o `map_df()`, uma das funções mais poderosas do pacote. Basicamente utilizamos a estrutura `map_df( ~ data_frame(x = .x" )`, onde x = o nome da coluna e .x a função anônima. Pra ficar mais claro, vamos à pratica.

```{r}
dados1 <- select_if(dados, is.numeric)
dados1 <- dados1 %>% map_df(~(data.frame(v_distintos = n_distinct(.x),
                              classe = class(.x),
                              media = round(mean(.x), digits = 2),
                              desvio_p = round(sd(.x), digits = 2),
                              minimo = min(.x),
                              maximo = max(.x))),
                 .id = "variavel")
dados1
```

No exemplo acima, começamos utilizando a função `select_if()` do pacote `dplyr` para pegar, do banco de dados original, apenas as variáveis do tipo númericas e armazenamos em um outro banco de dados (apenas para facilitar o entendimento). Após isso já começamos a pensar na medidas que queremos para acrescentar no banco de dados. Adicionamos então os valores distintos de cada variável, as classes (apenas para mostrar que `select_if()` fez o que queriamos) e algumas medidas resumo como média, desvio padrão, valores máximos e mínimos. Uma observação importante é que ao utilizar essa função de `map()`, o nome das variáveis são perdidos, por isso ao fim do código foi utilizado o `.id` (argumento de `map_df()`) para incluir o nome das variáveis. Veja o resultado. 

```{r}

knitr::kable(head(dados1))

```

# _"map2()"_

Após obtermos uma certa noção de como funcionam as funções de `map()` podemos falar de sua outra versão, a `map2()`. Essa função segue os mesmos critérios que a `map()` "original", porém permite que você trabalhe não só com um, mas com dois objetos. Em `map2()` também conseguimos especificar o tipo de saída da função, segue abaixo a lista de algumas das variações da função.


- `map2 (.x, .y, .f, ...)`

- `map2_dfc (.x, .y, .f, ...)`

- `map2_dbl (.x, .y, .f, ...)`

- `map2_chr (.x, .y, .f, ...)`

- `map2_lgl (.x, .y, .f, ...)`


Lembrando que `.x` e `.y` são os vetores da função e devem ter o mesmo tamanho, caso contrário a função retornará uma mensagem de erro. 


```{r}
dados3 <- dados %>% 
  group_by(Sepal.Width, Species) %>% 
  summarise(n = n())

largura <- dados3$Sepal.Width

especie <- dados3$Species

fmp2 <- function(x, y) paste("Espécie:", x, "largura:", y)

map2(especie, largura, fmp2) %>% head(5)
```

Acima criamos dois vetores, cada um contendo uma variável do banco de dados e depois criamos uma função simples, que irá concatenar, nesse caso, os dois vetores com algumas frases. Note que a função foi aplicada aos dois vetores. Uma observação é que no começo do exemplo criamos um outro banco de dados (dados3) com apenas as duas variáveis que foi usada no exemplo e agrupamos elas utlizando `group_by()` e`summarise()`. Isso foi feito apenas para que fosse possível ver os resultados com observações diferentes na saida da função.


É possível utilizar o `map()` para mais de dois objetos. Neste caso não existe um `map3()` ou `map4()` mas sim o `pmap()`. `pmap()` é basicamente uma generalização de `map2()` para 3 ou mais objetos. Essa função possui uma pequena diferença, nesse caso você não irá especificar n objetos dentro da função, mas sim apenas uma única lista que contém todos os vetores (ou listas).


###  Um uso um pouco mais elaborado de "map2()"

Veja o exemplo a seguir

```{r}
especies <- iris %>%  
  split(.$Species)

modelos <- especies %>% 
  map(~ lm (Sepal.Length ~ Petal.Length, iris ))

map2(modelos, especies, predict)



```

Primeiro usamos a função `split()` que divide os dados de entrada (x) em grupos diferentes (f). Um breve exemplo de como a função funciona.

```{r}
sp <- c(a = 1, b = 25, b = "exemplo", a = "split", a = 3)
sp

split(sp, f = names(sp))

```

No caso do nosso exemplo o objeto "especies" vai ser uma lista com as 3 `Species` presentes no banco de dados iris.

Depois partimos para criar o nosso modelo. Com ajuda da função `map()`, utilizamos a função `lm()` para criar o nosso modelo de regressão linear. A função `lm()` possui vários argumentos e maneiras de utilizar, não é nosso foco aprofundar nessa função, mas você pode saber mais clickando  [aqui](https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/lm). De maneira geral, fornecemos a função A variável preditora (ou independente) que nesse caso foi `Petal.Length` e a variável dependente (aquela que estamos tentando prever) que foi `Sepal.Length`, o segundo argumento é o banco de dados, nesse caso "iris", note o modelo segue “YVAR ~ XVAR”. Vamos dar uma olhada apenas em uma parte da função para entender melhor


```{r}
especies %>% 
  map(~ lm (Sepal.Length ~ Petal.Length, iris ))
```


O modelo linear retornou o comprimento da pétala (Petal.Length) de acordo com nosso comportamento de dados de entrada, comprimento da sépala (Sepal.Length). Note que para esse caso, para este banco de dados,  os valores retornados em cada espécie são os mesmos. 


Por fim fizemos o uso de `map2()` com os os objetos "modelos" e "especies", e aplicamos a função `predict()`. Em resumo, `predict()` serve para prever valores tendo como base um modelo (você pode se aprofundar nessa função clickando [aqui](https://www.rdocumentation.org/packages/stats/versions/3.6.2/topics/predict.lm)). Conseguimos prever então os tamanho das sépalas (Sepal.Length).


# Manipulações de listas 

Para mostrar algumas funções do purr que nos auxiliam na manipulação de listas, vamos tranfosrmar o banco de dados que estamos usando (iris) em uma lista de quadro de dados. Já fizemos isso no exemplo anterior, mas aqui para garantir que seja fácil de seguir e visualizar, vamos usar apenas 5 linhas de cada espécie.


```{r}
dados4 <- iris %>%  
  split(.$Species) %>%  
  map(~ sample_n(., 5))

dados4

```

### `keep(), discard() e compact()`

A função `keep()` e `discard()` são bem parecidas e _opostas_. `keep()` mantém apenas os elementos de uma lista que satisfazem uma determinada condição enquanto `discard()` faz exatamente o oposto (descarta quaisquer elementos que satisfaçam sua condição lógica). Essas funções possuem 2 argumentos principais, ".x" uma lista ou vetor e ".p" uma função de predicado. Apenas aqueles elementos .pavaliados como `TRUE` serão mantidos ou descartados, em outras palavras, a sua condição. Também é possível, como terceiro argumento, fornecer rgumentos adicionais transmitidos para ".p". `compat()` é uma função com argumentos parecidos com as anteriores, a diferença é que para essa função, o ".p" é uma função que é aplicada a cada elemento de .x e somente aqueles elementos ".p" avaliados como um vetor vazio (`NULL` ou listas com comprimento zero) serão descartados.


```{r}

dados4 %>% 
  keep(~{mean(.x$Petal.Width) > 0.5})

dados4 %>% 
  discard(~{mean(.x$Petal.Width) > 0.5})


list(a = "a", b = NULL, c = integer(0), d = NA, e = list()) %>%
  compact()
```


### `every()`, `some()` e `none()`

Caso a gente queira saber se Todos, alguns ou nenhum dos elementos de uma lista satisfazem um determinado critério, podemos usar as funções `every()`, `some()` e `none()`, respectivamente. Essas funções são básicas e possuem apenas dois argumentos, sendo o primeiro uma lista ou vetor e o segundo o critério. A saída da função sera valores lógicos (`TRUE` ou `FALSE`).


```{r}
dados4 %>% 
  every(~{mean(.x$Petal.Width) > 0.5})

dados4 %>% 
  some(~{mean(.x$Petal.Width) > 0.5})

dados4 %>% 
  none(~{mean(.x$Petal.Width) > 20})

```


Aqui podemos puxar um gancho para uma outra fução de pesquisa que também retorna um valor lógico, `has_element`. Basciamente serve para testar se uma lista ou vetor contém um determinado objeto, a função tem o seguinte formato: 

- `has_element(.x, .y)`

onde `.x` é a lista ou  vetor e `.y` o objeto para testar

```{r}

has_element(dados$Petal.Width, 1.0)

has_element(dados$Species, 1.0)
```


### `reduce()`



# Referências

<https://www.rebeccabarter.com/blog/2019-08-19_purrr/>

<https://jennybc.github.io/purrr-tutorial/>


